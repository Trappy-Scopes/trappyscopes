{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"trappyscopes-cli","text":""},{"location":"#trappy-scopes-command-line-interface","title":"(Trappy-Scopes command line interface)","text":"<p><code>trappyscopes</code> is a python framework for building and controlling laboratory instruments. It facillitates the creation of highly heterogenous instrument assemblies by integration any existing python package. The aim of  <code>trappyscopes</code> is to enable fast deployment of paralel measurement systems that are software defined.</p> <p>The base model of this library imagines instruments as an arbitrary tree of python enabled computers and \"pythonic\" microcontrollers (micropython or circuitpython). With this base model, the control layer enables plug and play interfacing with minimal configuration. The key idea is to have the following workflow while building instruments.</p> <ol> <li>Connect all components with their respective interfaces (serial, ethernet, over wifi etc)</li> <li>Install this library and all required 3rd party packages for the components.</li> <li>Define the structure of the instrument in a configuraion file.</li> <li>You are done! Launch the cli to acquire data.</li> </ol>"},{"location":"#some-other-salient-features-of-the-framework","title":"Some other salient features of the framework","text":"<ol> <li>Pythonic interfacing</li> <li>Software defined infrastructure is at the core of lab management.</li> <li>Made to support parallelization and open-source instrumentation.</li> <li>Seemlessly interfaces with any existing python pacakge.</li> </ol>"},{"location":"#a-quick-example","title":"A quick example","text":"<p>Given the following configuration of instruments, where M1 and M2 are separate machines connected by a network:</p> <pre><code>graph LR\n  subgraph M1\n    M1_(\"Machine 1 (M1)\")\n    M1_ -.- S(\"Sensor (MS1)\")\n  end\n\n  subgraph M2\n    M2_(\"Machine 2 (M2)\")\n    M2_ -.- S_(\"Sensor (MS2)\")\n  end\n\n  M1 --mounts--&gt; M2\n</code></pre> <pre><code># These commands work on M1\nscope.MS1.read()\nscope.M2.MS2.read()\n</code></pre> <p>Given the configuration:</p> <pre><code>ScopeAssembly:\n  ...\n  MS1:\n    description: Sensor on Machine 1.\n    kind: sensor1.library.Sensor1Constructor\n    args: []\n    kwargs: {}\n  M2:\n    description: Machine 2 over netwwork.\n    kind: hive.processorgroups.remote.RemoteGroup\n    args: []\n    kwargs:\n      - automount: True\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Install through <code>pip</code></li> </ol> <p><pre><code>pip install trappyscopes\n</code></pre> 2. You can install directly from the source and install the environment using the inbuilt command to build the environment. This is the recomended method because it also installs some required binary packages.</p> <p><pre><code>git clone -r &lt;repo_link&gt;\ncd &lt;trappyscopes&gt;\npython main.py --install\n</code></pre>  + To simply skip the binaries:     <pre><code>pip install .\n</code></pre>  + Please check trappyscopes environment to learn more about building an environment for this utility.</p> <ol> <li> <p>Basic information about application startup    <pre><code>python main.py -h\n\n## Or\npython main.py --help\n</code></pre></p> </li> <li> <p>Once the installation is complete, <code>python main.py</code> can be replaced by <code>trappyscopes</code>. If the package was not installed on the system (exists locally in a subdirectory), the bash script <code>.\\trappyscopes</code> can be used. You might have to run <code>chmod +x trappyscopes</code> or <code>sudo +x trappyscopes</code> to provide executable priviledges to the script.</p> </li> </ol>"},{"location":"#configuring-the-scope","title":"Configuring the scope","text":"<ol> <li><code>trappyscopes</code> cli is configured through a <code>YAML</code> configuration file. Let\u00b4s start by generating a configurartion file.</li> </ol> <pre><code>python main.py --new_config\n</code></pre> <ul> <li>This generate the following files in the home directory:   <pre><code> (~)\n  |-trappyverse\n  . |- trappyconfig.yaml\n    .\n</code></pre></li> <li><code>trappyverse/trappyconfig.yaml</code> is the default configuration file name and should be unchanged. We can have more than one configuration file on a system. To start the software with a custom configuration file:</li> </ul> <p><pre><code>python main.py --config ~/parallelverse/customconfig.yaml\n\n## Override default configuration options with this file (useful when more than one scope \n## configurations need to be defined)\npython main.py --add_config ~/parallelverse/customconfig.yaml\n</code></pre> 3. Now let's look at the configuration file!   + Naming the scope The first two lines are these:</p> <pre><code>```yaml\nname: &lt;hostname&gt;          # Name of the scope, which defaults to hostname. The is defined as the global variable `scopeid` with the defaul startup recipie. \nkind: mystery-device      # A signle word descriptor for the device.\ndescription: The functionally has not been described yet # A short description of the functionality of the device.\n```\n</code></pre> <ul> <li> <p>These fields can be edited as such and are of little consequence in terms of programming. The <code>name</code> must be chosen with care, and it's recommened that it is also the hostname of the machine. This makes remote access easy and preventss conflicts. </p> </li> <li> <p><code>name: MDev</code> is a special name, which defines any device as a \"Development Scope\" and has some special priveledges. For more information, check the <code>MDev</code> entry in the notes.</p> </li> <li> <p>Scope configuration options Now let's set check some configuration options and learn what they do:</p> <pre><code>config:\n  trappydir: ~/trappyverse   # Directory where the configuration of the scope is stored.\n  ui_mode: interactive       # User interaction mode\n  venv:                      # Whether to use a virtual environment for \n      active: true                # Config block is active. The function is turned on.\n      command: source ~/opt/miniconda3/bin/activate \n      name: trappy                # Name of the virtual environment that will be called after the command\n    git_sync:                  # Automatically git-sync certain repositories\n      active: true                # Config block is active. The function is turned on.\n      command: git pull           # Exact command to use for git syncronisation\n      repos:                      # List of local repositories, where the command will be called\n        - ~/lab_protocols/\n        - ~/lab_scripts/                     \n    set_wallpaper: false       # This option will set a \"information\" panel as the wallpaper. This helps to id the device, incase of multiplexing.\n    log_level: 20              # Log level of the root logger. Use 10 for debug. 20 is info and higher.\n    config_server:             # Configuration files are synchronised with this server, when changed.         \n      active: true\n      server: &lt;ip&gt;/&lt;address&gt;\n      share: &lt;name-of-server-share&gt;\n      destination: \"{date}\"   # Sub folder inside the share. This will create a folder with the \"current date\" opon operation.\n      username: &lt;username&gt;\n      password: &lt;password&gt;\n    config_redact_fields:     # Fields that will be redacted, if the config file is copied\n      - username\n      - password\n    startup_recipie: core.startup  # Startup procedure that defines how the CLI environment is created. `core.startup.__init__.py` defines the default one.\n    startup_scripts:          # Scripts to run by default when the CLI is started.   \n    - ./scripts/script1.py\n    - ./scripts/script2.py\n</code></pre> <ul> <li>Note some key features here: </li> <li>Any mapping can be turned off by defining a field <code>active: false</code> inside it. If this argument is skipped, then it's assumed to be <code>true</code>.</li> <li>Custom addresses (like the <code>destination</code> in <code>config_server</code>) can be defined with an \"effifible\" string (inspired by the f-strings in python):      <pre><code>config_server:\n  destination: \"{date}_{scopeid}_{user}\" # -&gt; 2025_05_01_microscope1_User1\n</code></pre></li> <li>The following terms can be used: <code>scopeid</code>, <code>user</code>, <code>date</code>, and <code>time</code>.</li> </ul> </li> <li> <p>Define devices Now let's look at the default <code>ScopeAssembly</code> block below:</p> <pre><code>ScopeAssembly:\n  &lt;hostname&gt;: \n    description: \"Host processorgroup.\"\n    kind: hive.processorgroups.linux.LinuxMachine\n    args: []\n    kwargs: {}\n</code></pre> <ul> <li>The device that we see here is the host computing machine that is detected and mounted. It is one of the devices under the <code>ScopeAssembly</code>, which is identified as the global variable <code>scope</code>. Within the scope assembly, we can define an arbitrary number of devices with the follwing schema:</li> </ul> <pre><code>ScopeAssembly:\n  device_name:\n    active: true\n    description: Provide a meaningful description of the device.\n    kind: &lt;path.to.object.Constructor&gt;\n    args: []   # Arguments that are passed to the object constructor.\n    kwargs: {} # Keyword arguments passed to the object constructor.\n    # Optional configuration\n    metaclass: hive.detector.Detector  # Define the object as a detector and extend its functionality\n    read_method: capture  # Method of the origianl object that is interpreted as the \"read\" method.\n      args: []            # These will be wrapped in a `functools.partial` instance.\n      kwargs: {}          # These will also be wrapped in a `functools.partial` instance.\n    write_method: set # Similar to the \"read_method\" option.\n      args: []            # These will be wrapped in a `functools.partial` instance.\n      kwargs: {}          # These will also be wrapped in a `functools.partial` instance.\n</code></pre> <ul> <li>For more information regarding the optional configuration options, refer to: notes/devices.md.</li> </ul> </li> <li> <p>Experiment settings For now, we can leave the previous block as it was and quickly gloss over the <code>Experiment</code> configuration block:     TODO: Git auth for protocols.      </p> <pre><code>Experiment:\n  exp_dir: ~/experiments              # Default directory where experiments are stored\n  protocols_dir: ~/lab_protocols      # Directory where protocols are stored, This can also be a git-address.\n  calibration_dir: ~/calibration_dir  # Directory where calibrations are stored.\n  exp_dir_structure:                  # This is the directory structure, that will be created within every experiment.\n    - scripts\n    - postprocess\n    - converted\n    - analysis\n  exp_report: false                   # Whether the pdf report functionality is turned on or not.\n  eid_generator: core.uid.uid         # This is the funtion that will be called to generate experiment IDs. By default is calls `nanoid.generate('1234567890abcdef', 10)`\n  file_server:                        # File server for synchronisation of experiments\n    active: true\n    server: &lt;ip&gt;/&lt;address&gt;\n    share: &lt;name-of-server-share&gt;\n    destination: \"{date}\"\n    username: &lt;username&gt;\n    password: &lt;password&gt;\n</code></pre> </li> <li> <p>The configuration is defined in <code>core.permaconfig.config.py</code> as <code>TrappyConfig</code>. It uses the Confuse library as a base.</p> </li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<ol> <li> <p>Start-up and usage</p> </li> <li> <p>Open an interactive session:   <pre><code>./ts -su UserName\n</code></pre></p> </li> <li> <p>Scripts are an important part of running experimental procedures:</p> </li> <li> <p>The scripts are executed in sequence and can be used to load pre-defined experimental protocols:   <pre><code>ts &lt;script1&gt; &lt;script2&gt; &lt;script3&gt;\nts &lt;script1&gt; &lt;script2&gt; &lt;script3&gt;\nts --iterate 3 &lt;script1&gt; ## Run Script1 three times\n</code></pre></p> </li> <li> <p>Alternatively, to load a script/execute a script from the interactive session:   <pre><code>ScriptEngine.run(globals(), scripts=[\"scriptfile.py\"])\n</code></pre></p> </li> <li> <p>Start an experiment</p> </li> <li> <p>All data-collection should be done within the context of an <code>Experiment</code>. It manages the data and metadata collection for an experiment: </p> </li> </ol> <pre><code>exp = Experiment(\"test\")\n\n# OR\n# Constructs a better defnined name: 'MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc'\nexp = Experiment.Construct([\"test\", \"experiment\"])\n</code></pre> <ul> <li>Creation of an instance immediately changes the working directory to the experiment one. You should get the following output:</li> </ul> <pre><code>&gt;&gt;&gt; exp = Experiment.Construct([\"test\", \"experiment\"])\n{\n    'name': 'MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc',\n    'eid': '6a092b60dc',\n    'created': datetime.datetime(2025, 8, 23, 5, 55, 12, 771720),\n    'syspermastate': {\n        'mac_address': &lt;MAC:ADDRESS&gt;,\n        'ip_address': &lt;IP:ADDRESS&gt;,\n        'hostname': &lt;HOSTNAME&gt;,\n        'os': ['Darwin', '21.6.0']\n    }\n}\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 &lt;Session: 6a092b60dc&gt; \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n[05:55:13] INFO     Creating new experiment:                                  experiment.py:296\n                    MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Experiment open \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n           INFO     Loading Experiment:                                        experiment.py:305\n                    MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc\n           WARNING  Experiment state not found. Not a problem if this is a new experiment.      experiment.py:338\nWorking directory changed to:\n/Users/byatharth/experiments/MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc\n.\n\u251c\u2500\u2500 .experiment\n\u251c\u2500\u2500 analysis\n\u251c\u2500\u2500 converted\n\u251c\u2500\u2500 experiment.yaml\n\u251c\u2500\u2500 postprocess\n\u251c\u2500\u2500 scripts\n\u2514\u2500\u2500 sessions.yaml\n\n4 directories, 3 files\n\nuser:YB || \u2039\u2039MDev\u203a\u203a Experiment: MDev__YB__2025_08_23__5hh_55mm__test_experiment__6a092b60dc\n</code></pre> <ul> <li>The <code>Experiment</code> class manages the saving of data in  specific folders and logs experiement events. </li> <li>A folder qualifies as an Experiemnt if it contains the <code>.experiment</code> file with the unique identifier of the experiment.  The file <code>experiment.yaml</code> contains the event logs of the experiments, </li> <li> <p>Each time an experiment is open, a new session is created. An <code>Experiment</code> is a composed of an arbitrary number of sessions. The <code>sessions.yaml</code> contains the environment information (list of packages, version control number, etc) for each session.</p> </li> <li> <p>Additionally, you can use the following utility functions:   <pre><code>## Find and open an existing experiment\nexp = findexp() ## Press enter to open a prompt with available experiments\n\n## Find an delete an existing experiment\n## Warning: this is an irreversible deletion\ndelexp()\n</code></pre></p> </li> <li> <p>The <code>Experiment</code> philosophy is defined in the expframework submodule.</p> </li> </ul>"},{"location":"#lets-do-a-simple-experiment","title":"Let's do a simple experiment","text":""},{"location":"expframework/","title":"Experiment Framework (<code>expframework</code>)","text":"<p>This submodule describes an <code>Experiment</code> object with the following functionalities:</p> <ol> <li>Data management</li> <li>Recording proper metadata and preserving experimental conditions over different sessions</li> <li>Creating and managing independently timed measurement streams.</li> <li>Implement an Event Model to keep track of all digital and user steps.</li> </ol> <p>Some additional features that are implemented for convinience:</p> <ol> <li>Automatic pdf report generation: <code>ExpReport</code></li> <li>File synching with a file-server: <code>ExpSync</code></li> <li>Integrated protocol recording system and ScriptEngine</li> <li>Integrated plotting system</li> </ol>"},{"location":"expframework/#the-experiment-system","title":"The <code>Experiment</code> system","text":""},{"location":"expframework/#what-is-an-experiment","title":"What is an Experiment?","text":"<p>An experiment is a series of operations done by a human or manchine to investigate a scientific question. To answer a scientific question, the <code>User</code> typically describes an experimental system, and gathers multiple streams of measurements (a timelapse of microscopy images), a timeseries of temperature. This data is further analysed to make scientific deductions or to test a hypothesis. The Trappy-Scopes <code>expframework</code>submodule formalizes this very general procedure in the following way:</p> <p>We imagine the following: A scientist in the lab creates the observable (and interesting!) phenomena in a tiny box and observes it. This observation leads to scientific discovery. To make this happen, we need a box (or a system) where this phenomena happens and the means to manipulate the state of this box. Further, we need eyes to observe the phenomena and a systematic way of detailing it. The box can be approximated by a set of scientific instruments:</p> <ol> <li>Actuators: insturments that can change the state of a system</li> <li>Detectors: instruments that can read information (detect phenomena)</li> <li>Processors: instruments that control the above two and records information</li> </ol> <p>A <code>ScopeAssembly</code> describes one or many scientific instruments. The devices within these assembly are used to create and change the environment of the experimental system. A simple example is below:</p> <p>We have a microscope with a red light source and we need to record an image of the sample.</p> <pre><code>scope ## &lt; Scope Assembly :: 6 devices :: microscope&gt;\nscope.red.setVs(2) ## Set red channel to 2V (actuator)\nscope.cam.read(\"img\", \"red_image_png\") ## Record an image on the camera (detector)\n</code></pre> <p>An <code>Experiment</code> is an additional construct around the code used to control the instument. To emit anykind of datafile from the <code>ScopeAssembly</code> construct, an experiment has to be created. </p> <p>An <code>Experiment</code> is typically composed of multiple <code>Sessions</code>. Everytime, an experiment is open or closed, or a user logoffs and a new one logs in, the session is changed. A <code>User</code> is the person/machine that is operating the experiment or the scope. It\u00b4s only usage is to determine ownership of the data and to furnish user information metadata.</p> <p>An <code>Experiment</code> at its core is a seperate directory for storing datafiles. Additionally, it is composed of multiple streams of measurements and clocks to time different events. Further, it records a list of events in cronological order. Many generic events that may be needed to program an experiment (like delays, prompts, recurring tasks) are available within the framework and are programmed to automatically log themselves.</p>"},{"location":"expframework/#componets-at-a-glance","title":"Componets at a glance","text":"<p>The following graph represents an <code>Experiemnt</code> context. The framework can be understood completely by understanding these different components.</p> <pre><code>Experiment {name, unique eid}\n*- root directory: (datafile1, datafile2, ... datafileN)\n|- payload (postprocess, analysis, converted)\n|- scripts (directory of all executed scripts)\n:-&lt;user and session&gt;---------------------------------------------------------------\n|- User                                                              :: User.name() \n|- Session1, Session2, Session3, ..., SessionN                       :: exp.sessions\n::-&lt;parameters and measurements&gt;----------------------------------------------------\n|- attributes (parameters for the experiment)                        :: exp.attribs\n|- MeasurementStream1, MeasurementStream2,...MeasurementStreamN      :: exp.mstreams\n::-&lt;time and events&gt;----------------------------------------------------------------\n|- expclock, {&lt;additional clocks&gt;}                                   :: exp.clocks\n|- scheduler (for scheduling/timing operations, `ExpSchedule`)       :: exp.schedule\n|- ExpEvent1, ExpEvent2, ExpEvent3, ... ExpEventN (`[ExpEvent, ]`)   :: exp.events\n::-&lt;metadata and description&gt;--------------------------------------------------------\n|- notebook (a series of timed notes by the user)                    :: exp.notebook\n|- report (a pdf report w measurements and all events)               :: exp.report                              \n|- logs  (everything described above and more metadata)              :: exp.logs\n::-&lt;utilities&gt;-----------------------------------------------------------------------\n|- additional services (ExpSync, ExpGit)  \n*\n</code></pre>"},{"location":"expframework/#create-an-experiemt","title":"Create an experiemt","text":"<p>An <code>Experiment</code> is  with <code>exp = Experiment(\"experiment_name\")</code>. A new session is created automatically, everytime the user restarts the trappy-scopes application, or when a new experiment is created. By creating an experiemt, you automatically  change the working directory to the one created by the experiment. Within the experiment directories, files can be created as such.</p> <p>You can also construct an experiment using a few fields:</p> <pre><code>exp = Experiment.Construct([\"longterm\", \"temp\", \"curve\"], scopeid=True, \\\n                           username=True, date=True, time=True, eid=True)\n## creates: MDev__YB__2025_03_09__0hh_16mm__longterm_temp_curve__3f58ee69ec\n</code></pre>"},{"location":"expframework/#data-storage-and-corresponding-utilitiesexpsyncand-expgit","title":"Data storage  and corresponding utilities(<code>ExpSync</code>and <code>ExpGit</code>)","text":"<p>With the creation of an experiment, the directory of the REPL changes to the <code>exp.exp_dir</code>.  All files created from the python REPL or from a script would emit files in this folder. To mark the creation of a file using and <code>ExpEvent</code>, the method <code>exp.newfile</code> method. </p> <p>The <code>ExpSync</code> extension provides an interface to synchronise files using [<code>rsync</code>])(https://rsync.samba.org/). Rightnow the utility only supporst samba shares on linux and mac os. A <code>file_server</code> configuration block can be added to enable it:</p> <pre><code>file_server:\n    active: true                     ### option switcg\n    destination: \"{date}\"  ### destination folder from the root of the share [effify]\n    server: 172.22.63.19   ### ip address of the server \n    share: share_folder    ### share folder (there are multiple shres on the same ip)\n    username: admin       ### username for authentification.\n    password: pass              ### password for authentification.\n ## [effify]: supports fields: date, time, user, scopeid\n</code></pre>"},{"location":"expframework/#todo-the-expgit-utility-can-be-additionally-enabled-to-track-the-changes-in-the-experiment-the-utility-can-be-setup-to-exclude-large-data-files-which-it-does-by-default-this-could-be-used-as-an-extra-protection-against-poor-event-modelling","title":"todo The <code>ExpGit</code> utility can be additionally enabled to track the changes in the experiment. The utility can be setup to exclude large data files (which it does by default). This could be used as an extra protection against poor event modelling.","text":""},{"location":"expframework/#measurement-streams","title":"Measurement Streams","text":""},{"location":"expframework/#scheduler-expscheduler-todo","title":"Scheduler (<code>ExpScheduler</code>) #todo","text":"<p><code>ExpScheduler</code> uses the schedule API to manage and schedule tasks at a cetrain recurring frequency or at a given time. The module can be used in the following way:</p> <pre><code>exp.schedule.every(10).minutes.do(record_temp)\n</code></pre> <p>It is instructive to read this paragraph on the pecularities of event scheduling: here. The <code>ExpSchedule</code> module automatically starts a thread to execute the remaining jobs, hence, <code>schedule.run_pending()</code> should not be called explicitly.</p>"},{"location":"expframework/#experiment-notes","title":"Experiment notes","text":"<p>Notes can be logged in the dataset as special <code>ExpEvent</code>: <code>user_note</code>. The functions <code>exp.note</code>, <code>exp.write</code> can be used to log specific notes.</p> <p>The <code>exp.notebook</code> property (implemented in the <code>ExpNotebook</code> class can be used to access the whole notebook at once.</p>"},{"location":"expframework/#other-tools","title":"Other Tools:","text":"<ol> <li><code>exp.delay</code>: a better replacement to <code>time.sleep</code>.</li> <li><code>exp.track</code>: time and log execution of a function.</li> <li><code>exp.user_prompt</code>: accept input (prompt) from the user.</li> <li><code>exp.multiprompt</code>: accept multiple prompts from the user.</li> <li><code>exp.interrupt</code>: mark an interruption in the experiment sequence.</li> </ol>"},{"location":"notes/assmble_trappy_scopes/","title":"Assemble a trappy scope","text":"<p>Broad steps:</p> <ol> <li>Print the frame</li> <li>Assemble the electronics</li> <li>Assmble the frame</li> <li>Install trappy scopes software</li> <li>Done!</li> </ol>"},{"location":"notes/assmble_trappy_scopes/#1-print-the-frame","title":"1. Print the frame","text":"<p>The frame of the trappy scopes 3D-printed opto-mechanical assembly is available at: https://github.com/Trappy-Scopes/trappyframe/ . The scope can be entirely printed with PLA (recommended PLA 3D860 Black). The frame can be mounted on any standardised 6mm Stainless Steel Rods (X4, recommended length is 50cm for each). The compnents use self tightening flexure mechanisms and do not require thread-inserts. Standardised 3mm and 4mm hex screws (10mm length) are sufficient for most mounts. Additionally, 2.6mm and 1mm small screws are required for mounting of electronics and cameras.</p> <p>It is recommended that you use no screws while mounting the components on the rods and only use screws for tightening them. Movement of compinents while the screws are tightened leads to faster wear &amp; tear, and faster misalignemnt of frmae rods.</p>"},{"location":"notes/assmble_trappy_scopes/#2-assemble-the-electonics","title":"2. Assemble the electonics","text":"<ol> <li>Raspberry Pi Pico W microcontroller: A library of trappy-scopes electronics is available at: https://github.com/Trappy-Scopes/electronics . These are easy to assmble PCBs and use Raspberry Pi Pico W as the base microcontroller. A specialised firmware (available at: https://github.com/Trappy-Scopes/pico_firmware) can be used to multiplex between the different software defined configurations. The firware can be flashed from the trappy-scopes scope-cli, once micropython is installed.</li> </ol> <p>Installtion of micropython (recommended) on the pico devies can be done using Thonny IDE: https://thonny.org/ .</p> <ol> <li>Raspberry Pi SoC: Raspberry Pi OS 64Bit is recommended on micro-SD cards. Instructions can be found here: https://www.raspberrypi.com/documentation/computers/getting-started.html . Suffiecient cooling should be provided to the SoC. To operate trappy-scopes in a parallel scope configuration, refer to the following repositiory: https://github.com/Trappy-Scopes/multiplexed_clusters . </li> </ol>"},{"location":"notes/assmble_trappy_scopes/#3-assmble-the-frame","title":"3. Assmble the frame","text":"<p>We have the frame printed and the electronics ready. So let's assemble a trappy-scopes microscope!</p> <p>## Assemble a single unit</p> <p>The instuctions to assemble a single unit are present here: https://github.com/Trappy-Scopes/trappyframe/blob/main/assembly.md</p>"},{"location":"notes/assmble_trappy_scopes/#assemble-the-cluster","title":"Assemble the cluster","text":"<p>The cluster assembly instructions can be found here: https://github.com/Trappy-Scopes/multiplexed_clusters</p>"},{"location":"notes/assmble_trappy_scopes/#assemble-controller-units","title":"Assemble Controller units","text":"<p>Controller units are additional machines that aggregate many micropython controlled devices on a single linux machine. They provide a terminal to control the devices directly and also aid in network connectivity through the Ethernet interface.</p> <p>The instructions to make a controller unit can be found here: https://github.com/Trappy-Scopes/more_screens</p>"},{"location":"notes/assmble_trappy_scopes/#4-install-trappy-scopes-software","title":"4. Install trappy scopes software","text":"<p>The homepage of the Trappy-Scopes scope-command/control-line-interface can be found here: https://github.com/Trappy-Scopes/scope-cli.</p> <p>The instructions to finish the installation are as follows:</p> <pre><code>cd ~ ## Home folder or whereever you want it!\ngit clone https://github.com/Trappy-Scopes/scope-cli\n</code></pre> <p>Install all required python packages: <pre><code>cd scope-cli\n./trappyscope --install\n</code></pre></p> <p>Flash <code>pico_firmware</code> on the micropython devices:</p> <p>Connect all micropython devices on the machine using serial connection:</p> <pre><code>## Inside the scope-cli folder\npython -i main.py\nfrom core.installer import mpyfirmware\nmpyfirmware.scan() ## List all micropython device ports\nmpyfirmware.flash(port)\n</code></pre> <p>You would notice that initally, a lot of errors are thrown by the CLI. This is probably because we have not defined the device configuration yet. Each \"scope\" needs to be defined in some degree into a <code>deviceid.yaml</code> file in the <code>config</code> folder.</p> <pre><code>name: MDev           ## Required! And should be the same as the RPi hostname\ntype: microscope     ## This instucts the software to make a microscope!\n\n\n\nassembly:  ## Superficial descriptions of the system, the bracketed entities are distances between components and are optional (useful for opto-mechanics)!\n</code></pre> <ol> <li>Done!</li> </ol> <p>The instructions to use the interface can be found on detail at: https://github.com/Trappy-Scopes/scope-cli. In short, all of these are similar:</p> <pre><code>python -i main.py  ## The very basic\n./trappyscope      ## Shorthand optimised call\npython viewer.py   ## To have an additional gui interface.\n</code></pre>"},{"location":"notes/devices/","title":"All the Devices in the Trap-Scopes System (Trappy-System)","text":"<p>Design and implementation document. This document outlines the vision of the <code>hive</code> module.</p> <p>A <code>SimpleDevice</code> is a device that is atomic and does not have any other devices/abstractions attached to it. A <code>ComplexDevice</code> is a multi-layered device, whcih can functionally emit/resolve proxies to the sub-devices that are attached to it.</p> <p>Types:</p> <ol> <li><code>SimpleDevice</code> : stores basic attributes and has no functional significance.</li> <li><code>ComplexDevice</code>: Can emit proxies.</li> </ol> <p>A <code>BaseDevice</code> is a group of processors which can be accessed by a single  <code>shell</code> (<code>device.exec()</code> method) instance and have their own independent operating system/firmware.</p>"},{"location":"notes/devices/#hierarchy-and-connections","title":"Hierarchy and connections","text":"<pre><code>graph TD\n    ProcessorGroup --&gt; LinuxDevice\n    abcs.BaseDevice --&gt; MicropythonDevice\n\n    LinuxDevice --&gt; RPiLinuxDevice\n    LinuxDevice --&gt; *GenericLinuxDevice\n\n    MicropythonDevice --&gt; SerialMPDevice\n    MicropythonDevice --&gt; NetworkMPDevice\n    MicropythonDevice --&gt; NullMPDevice\n\n</code></pre>"},{"location":"notes/devices/#common-connection-idioms","title":"Common Connection Idioms","text":"<pre><code>graph LR\n\nLinuxDevice &lt;--USB--&gt; SerialMPDevice\nLinuxDevice &lt;--Wifi--&gt; NetworkMPDevice \n\nLD2[LinuxDevice] &lt;--Ethernet--&gt;LD3[LinuxDevice]\n\n</code></pre>"},{"location":"notes/devices/#basedevice-specifics","title":"<code>BaseDevice</code> specifics","text":""},{"location":"notes/devices/#shell-and-main","title":"Shell and \"main\"","text":"<pre><code>graph LR\n\n    LinuxDevice --\"connects-to\"--&gt; bash-shell --exec_main() --&gt; linuxmain(python-cli\\n./scope-cli/main.py or \\n./scope-cli/.trappyscope)\n\n    MicropythonDevice --\"connects-to\"--&gt; mpy-shell --exec_main() --&gt; mpymain(\"create-devices : execfile('main.py')\")\n</code></pre>"},{"location":"notes/devices/#processor-group","title":"Processor Group","text":"<p>The <code>BaseDevice</code>handles the processor group and keep tracks of processor consumption and load. A <code>LinuxDevice</code> can make the decision to disconnect power on itself under zero prospective load.</p>"},{"location":"notes/devices/#basedeviceproxy","title":"<code>BaseDevice.Proxy</code>","text":"<p>All <code>BaseDevice</code> instances can  emit proxy devices that are either actual or virtual peripherals that are connected downstream to them. This allows the upstream BaseDevice to directly access them.</p> <pre><code>\n</code></pre>"},{"location":"notes/hive/","title":"<code>hive</code> module","text":""},{"location":"notes/hive/#laboratory-level-structure","title":"Laboratory level structure","text":"<pre><code>flowchart TD\n    Lab((\u00a0\u00a0\u00a0\u00a0\u00a0Lab\u00a0\u00a0\u00a0\u00a0\u00a0)) --&gt; SA([ScopeSeembly 1])\n    Lab --&gt; SA2([*ScopeSeembly 2])\n    Lab --&gt; SA3([*ScopeSeembly 3])\n    Lab --&gt; SA4([*ScopeSeembly 4])\n    Lab --&gt; SA5([\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"])\n</code></pre> <p>$*$ : It's a remote SSH/Rpyc connection layer that mimics the actual scope assembly.</p>"},{"location":"notes/hive/#scope-level-structure","title":"Scope level structure","text":"<pre><code>flowchart TB\n    SA((\"ScopeAssembly\"))\n    SA --&gt; devicelists\n    SA --&gt; abstracts\n\n\n    subgraph abstracts\n    direction LR\n    Microscope\n    RayOptics\n  end\n\n    subgraph devicelists\n        direction LR\n        basedevices([basedevices])\n    actuators([actuators])\n    detectors([detectors])\n    processorgroup([processorgroup])\n    tree([tree])\n  end\n\n\n</code></pre>"},{"location":"notes/hive/#scopeassmebly","title":"ScopeAssmebly","text":"<p>The scope assembly is composed of two paradigms:</p> <ol> <li> <p><code>devicelists</code>: collection of available peripheral devices which are non-unique and can be shared across groups.</p> <ol> <li><code>basedevices</code>: collection of all devices, as everything derives from the <code>BaseDevice</code> object.</li> <li><code>actuators</code> : collection of all objects that inherit the <code>Actuator</code> interface.</li> <li><code>detectors</code> : collection of objects that inherit the <code>Detector</code>interface.</li> <li><code>processgroups</code>: collection of objects that represent processors and can be used to launch processes.</li> <li><code>tree</code>: a tree data structure that sequentially mounts all peripherals into a tree datastructure.</li> </ol> </li> <li> <p><code>abstracts</code> : collection of modules that create virtual abstractions to a collection of devices. A few examples are below:</p> <pre><code>## A Simple Microscope Abstraction\nclass Microscope:\n  def __init__(self, scopeassembly):\n    self.lights = scopeassembly.lights\n    self.cam = scopeassembly.cam\n    self.x_motor = scopeassembly.motorset[0]\n    self.y_motor = scopeassembly.motorset[1]\n    self.z_motor = scopeassembly.motorset[2]\n</code></pre> <pre><code>## A simple lux estimator using a CMOS camera (which implements the __lux__ function)\nfrom hive.detector import Detector\nclass CamLux(Detector):\n  def __init__(self):\n    from functools import partial\n\n    ##  Average the lux for 30 seconds at the default fps of the camera\n    read = partial(scopeassembly.camera.read, \"__lux__\", tsec=30)\n    self.read = read\n\n\nclass LuxEstimator:\n  def __init__(self, scopeassembly):\n    self.sensor = CamLux()\n    self.led = scscopeassembly.led ## Single channel\n\n  def V_lux_curve(self):\n    results = {}\n    for v in np.arange(0, 3, 0.1):\n      self.led.setV(v)\n      results[v] = self.sensor.read()\n    return results\n</code></pre> </li> </ol>"},{"location":"notes/intro/","title":"Trappy Scopes Control Layer","text":"<p>A quick how-to-trap guide.</p>"},{"location":"notes/intro/#0-login","title":"0. Login","text":"<ul> <li><code>User.login(\"CC\")</code> : log user in.</li> <li><code>User.logout</code> : log user out.</li> </ul>"},{"location":"notes/intro/#1-create-an-experiment","title":"1. Create an <code>Experiment</code>","text":"<ul> <li><code>exp = Experiment(new_exp_name)</code> : create a new experimet.</li> <li><code>exp = findexp()</code> : would open a prompt where you can search the experiment by name.</li> <li><code>exp.close()</code>  : to close the experiment.</li> <li><code>exp.sync_dir()</code> : to synchronise the experiment directory on the file server.</li> <li><code>ScripEngine.now(globals(), \"scripts/folder/scriptname.py\")</code> : to run the script now.</li> <li><code>exp.params/exp.attribs</code> : is a dictionary of all the control parameters.</li> <li><code>Experiment.current</code> holds the current experiment object.</li> </ul>"},{"location":"notes/intro/#2-use-the-scope","title":"2. Use the Scope","text":"<ul> <li><code>scope</code> is <code>ScopeAssembly.current</code></li> <li><code>scope.draw_tree()</code> : to inspect the scope.</li> <li><code>scope.lit.setVs(2,0,0)</code> : to set lights.</li> <li><code>scope.cam.read(\"img\", \"test.png\")</code> : record a picture.</li> </ul>"},{"location":"notes/intro/#3-understand","title":"3. Understand","text":"<ul> <li>Use <code>help(object/fn)</code> or better <code>explorefn()</code> to find out what it does.</li> <li>Use <code>codeviewer()</code> to directly inspect code in the terminal in a safe fashion.</li> </ul>"},{"location":"notes/mdev/","title":"MDev","text":""},{"location":"notes/optics/","title":"Optics","text":""},{"location":"notes/optics/#introduction","title":"Introduction","text":"<p>The optical description for a <code>scope</code> is described by the <code>optics</code> module. The module is responsible for reading the <code>device.yaml</code> description and rendering a computational model in th</p>"},{"location":"notes/optics/#recommended-packages","title":"Recommended Packages:","text":"<ol> <li><code>rayoptics</code>         : framework for defining and manipulating optical assemblies.</li> <li><code>opticalglass</code>   : has a catalogue of materials and their optical properties.</li> <li>POPPY: Physical Optics Propagation in Python : for geometric optics.</li> </ol>"},{"location":"notes/picamera2/","title":"PiCamera 2 Library","text":""},{"location":"notes/picamera2/#camera-construction-and-configuration","title":"Camera Construction and Configuration","text":"<ol> <li>The <code>camera.open()</code> function creates a new <code>PiCamera2</code> object and assigns it to the <code>cam</code> attribute.</li> <li>The camera object then needs to be configured: <code>camera.configure()</code> to the correct settings. There are several ways. More short-hand functions are described in the constructor.</li> </ol> <pre><code>flowchart LR\n    Camera --&gt; construct(\"Camera() or camera.open()(camera is open)\")\n    Camera --&gt; configure(\"cam.configure()(camconfig.yaml)\")\n    Camera --&gt; configure2(\"cam.configure(res=[x,y], fps=20)(set custom configuration)\")\n    Camera --&gt; configure3(\"cam.configure(config)(set a full custom configuration)\")\n\n\n\n\n</code></pre> <ol> <li></li> <li> <p>There are <code>streams</code>, <code>outputs</code>, and <code>encoders</code>. All of these need to be created and connected for the camera to work.</p> </li> <li>QT windows are blocking in nature. It is important to understand how to make them async and non-blocking.</li> </ol>"},{"location":"notes/picamera2/#stream-configurations","title":"Stream Configurations","text":"<ul> <li>default: fps=30, res = 1980X1080</li> <li> <p>default2 : fps=30, res = 2028X1080</p> </li> <li> <p>largeres : fps=10, res=4056X3040</p> </li> <li>largefps : fps=120.03, res=1332X990</li> </ul> <p>Configuration and Control Structures:</p> <ul> <li>\"preview\" : used for previews. \u2014 no auto adjustments.</li> <li>\"still\" : used for images. \u2014 no auto adjustments.</li> <li>\"video\" : used for videos \u2014 no auto adjustments.</li> <li>\"default\" : default video configuration \u2014 all auto adjustments enabled as in defaults.</li> </ul> <p>Image Formats: </p> <ol> <li>For most operations: <code>XBGR8888</code> : [R, G, B, 255]. It is the default.</li> <li>For Raw Captures, it must be set to: <code>BGR888</code> : [R, G, B]</li> </ol>"},{"location":"notes/picamera2/#picamera-2-harware-isp-model","title":"PiCamera 2 Harware-ISP Model","text":"<pre><code>flowchart LR\n\n    Camera --&gt; CSI-2-Receiver --&gt; Memory --&gt; raw-stream\n                                                                Memory --&gt; ISP(ISPImage Signal Processor)\n                                                                ISP --&gt; main-stream\n                                                                ISP --&gt; lowres-stream\n\n\n    Camera-Memory -.stream.- main\n    Camera-Memory  -.stream.- lores\n    Camera-Memory  -.stream.- raw\n    Controls -.sets.-&gt; Camera\n\n    main --- Streams\n    lores --- Streams\n    raw --- Streams\n\n    Configuration -.sets.-&gt; Streams\n    Streams --&gt; Encoder\n    Encoder --&gt; OutputObject\n    Encoder &lt;-.- H264Encoder([H264Encoder])\n    OutputObject --&gt; Capture[[Capture]]\n    OutputObject &lt;-.- FFmpegOutput([FFmpegOutput])\n    OutputObject &lt;-.- FileOutput([FileOutput])\n\n\n</code></pre> <ul> <li>The main and lores streams need to have the same <code>colour_space</code> whereas, the raw stream has the camera hardware defined color space. The choise is left to the PiCamera2 autosettings.</li> <li></li> </ul>"},{"location":"notes/picamera2/#modes-of-operation","title":"Modes of operation:","text":"<ol> <li>\"preview\" : Gray window</li> <li>\"image\": Working corretly, however the startup overhead is significant.</li> <li>\"image_trig\" : Gray window and process blocks indefinately after trigger.  </li> <li>\"timelapse\"    : Not tested </li> <li>\"video\"        : Ok</li> <li>\"videomp4\"     : Ok   </li> <li>\"video_noprev\" : Ok </li> <li>\"video_raw\"    : Implemented  </li> <li>\"ndarray\"          : Not implemented</li> <li>\"stream\"         : Not implemented</li> </ol>"}]}